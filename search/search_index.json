{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Gitz","text":"<p>Write fluent interactions to Git using the <code>gitz</code> library. Programmatically crafting git commands becomes a breeze! Verify your code using the inbuilt testing framework.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2023 Purple Clay</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"git/checks/","title":"Git checks and how to use them","text":"<p><code>gitz</code> comes with a series of inbuilt checks for inspecting the environment and current repository.</p>"},{"location":"git/checks/#checking-for-the-existence-of-a-git-client","title":"Checking for the existence of a Git Client","text":"<p>When creating a new client, <code>gitz</code> will check for the existence of git using the <code>PATH</code> environment variable. An error is returned if no client exists.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, err := git.NewClient()\nif err != nil {\nlog.Fatal(err.Error())\n}\nfmt.Println(client.Version())\n}\n</code></pre>"},{"location":"git/checks/#checking-the-integrity-of-a-repository","title":"Checking the integrity of a Repository","text":"<p>Check the integrity of a repository by running a series of tests and capturing the results for inspection.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nrepo, err := client.Repository()\nif err != nil {\nlog.Fatal(\"failed to check the current repository\")\n}\nfmt.Printf(\"Default Branch: %s\\n\", repo.DefaultBranch)\nfmt.Printf(\"Shallow Clone:  %t\\n\", repo.ShallowClone)\nfmt.Printf(\"Detached Head:  %t\\n\", repo.DetachedHead)\n}\n</code></pre> <p>Example output when checking the integrity of a repository cloned within a CI system:</p> <pre><code>Default Branch: main\nShallow Clone:  false\nDetached Head:  true\n</code></pre>"},{"location":"git/clone/","title":"Cloning a Repository","text":"<p> Git Documentation</p> <p>Clone a repository by its provided URL into a newly created directory and check out an initial branch forked from the cloned repository\u2019s default branch.</p>"},{"location":"git/clone/#clone-everything","title":"Clone everything","text":"<p>Calling <code>Clone</code> will result in a repository containing all remote-tracking branches, tags, and a complete history.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Clone(\"https://github.com/purpleclay/gitz\")\nif err != nil {\nlog.Fatal(\"failed to clone repository\")\n}\n}\n</code></pre>"},{"location":"git/commit/","title":"Committing changes to a Repository","text":"<p> Git Documentation</p> <p>Create a commit (snapshot of changes) within the current repository and describe those changes with a given log message. A commit will only exist within the local history until pushed back to the repository remote.</p>"},{"location":"git/commit/#commit-a-snapshot-of-repository-changes","title":"Commit a Snapshot of Repository Changes","text":"<p>Calling <code>Commit</code> with a message will create a new commit within the repository:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// stage all changes to files and folders\n_, err := client.Commit(\"feat: a brand new feature\")\nif err != nil {\nlog.Fatal(\"failed to commit latest changes within repository\")\n}\n}\n</code></pre> <p>And to verify its creation:</p> <pre><code>$ git log -n1\n\ncommit 703a6c9bc9ee91d0c226b169b131670fb92d9a0a (HEAD -&gt; main)\nAuthor: Purple Clay &lt;**********(at)*******&gt;\nDate:   Mon Feb 20 20:43:49 2023 +0000\n\n    feat: a brand new feature\n</code></pre>"},{"location":"git/log/","title":"Inspecting the Commit Log of a Repository","text":"<p> Git Documentation</p> <p>Retrieve the commit log of a repository in an easy-to-parse format.</p>"},{"location":"git/log/#view-the-entire-log","title":"View the entire log","text":"<p>Calling <code>Log</code> without any options will retrieve the entire repository log from the current branch. A default formatting of <code>--pretty=oneline --no-decorate --no-color</code> is applied by <code>gitz</code> during log retrieval:</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nlog, err := client.Log()\nif err != nil {\nlog.Fatal(\"failed to retrieve repository log\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre> <p>Printing the <code>Raw</code> output from this command:</p> <pre><code>99cb396148cff7db435cebb9a8ea95a11b5658e1 fix: input string parsing error\ne8b67f90c613340fd61392fda03181d86a7febbe ci: extend existing build workflow\nc90e819baa6ddc212811924c51256e65f53d4c32 docs: create mkdocs documentation\n1635f10b81a810833b163793e6ef902d52a89789 feat: add first feature to library\na09348464773e99dbc94a5494b5b83b253c18019 initialized repository\n</code></pre> <p>By default, <code>gitz</code> parses the log into a structured output accessible through the <code>Commits</code> property. This structure contains each commit's associated <code>Hash</code>, <code>Abbreviated Hash</code>, and <code>Message</code>.</p>"},{"location":"git/log/#return-only-raw-output-from-the-log","title":"Return only raw output from the log","text":"<p>Use the <code>WithRawOnly</code> option to skip parsing of the log into the structured <code>Commits</code> property, improving performance. Perfect if you want to carry out any custom processing.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nlog, err := client.Log(git.WithRawOnly())\nif err != nil {\nlog.Fatal(\"failed to retrieve repository log\")\n}\nfmt.Println(log.Commits)\n}\n</code></pre> <p>Printing the <code>Commits</code> property should now be an empty slice:</p> <pre><code>[]\n</code></pre>"},{"location":"git/log/#view-the-log-from-a-point-in-time","title":"View the log from a point in time","text":"<p>When retrieving the log history, the <code>WithRef</code> option provides a starting point other than HEAD (most recent commit). A reference can be a <code>Commit Hash</code>, <code>Branch Name</code>, or <code>Tag</code>. Output from this option will be a shorter, fine-tuned log.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nlog, err := client.Log(git.WithRef(\"0.1.0\"))\nif err != nil {\nlog.Fatal(\"failed to retrieve log for tag 0.1.0\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre>"},{"location":"git/log/#view-a-snapshot-of-the-log","title":"View a snapshot of the log","text":"<p>The <code>WithRefRange</code> option provides a start and end point for retrieving a snapshot of the log history between two points in time. A reference can be a <code>Commit Hash</code>, <code>Branch Name</code>, or <code>Tag</code>. Output from this option will be a shorter, fine-tuned log.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nlog, err := client.Log(git.WithRefRange(\"0.2.0\", \"0.1.0\"))\nif err != nil {\nlog.Fatal(\"failed to retrieve log between tags 0.2.0 and 0.1.0\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre>"},{"location":"git/log/#view-the-log-of-any-files-or-folders","title":"View the log of any files or folders","text":"<p>Fine-tune the log history further with the <code>WithPaths</code> option. Providing a set of relative paths to any files and folders within the repository will include only commits related to their history.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// commits are made to the following files in a newly initialized\n// repository:\n//  &gt; a.txt\n//    ~ fix: typos in file content\n//  &gt; b.txt\n//    ~ chore: restructure file into expected format\n//  &gt; dir1 (b.txt, c.txt)\n//    ~ feat: a brand new feature\nlog, err := client.Log(git.WithPaths(\"a.txt\", \"dir1\"))\nif err != nil {\nlog.Fatal(\"failed to retrieve log using custom paths\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre> <p>Printing the <code>Raw</code> output from this command:</p> <pre><code>d611a22c1a009bd74bc2c691b331b9df38828dae fix: typos in file content\n9b342465255d1a8ec4f5517eef6049e5bcc8fb45 feat: a brand new feature\n</code></pre>"},{"location":"git/log/#cherry-picking-a-section-of-the-log","title":"Cherry-picking a section of the log","text":"<p>Cherry-pick a section of the log by skipping and taking a set number of entries using the respective <code>WithSkip</code> and <code>WithTake</code> options. If combined, skipping has a higher order of precedence:</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// assuming the repository has the current history:\n//  ~ docs: document fix\n//  ~ fix: filtering on unsupported prefixes\n//  ~ docs: create docs using material mkdocs\n//  ~ feat: add new support for filtering based on prefixes\n//  ~ initialized the repository\nlog, err := client.Log(git.WithSkip(1), git.WithTake(2))\nif err != nil {\nlog.Fatal(\"failed to retrieve log using custom paths\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre> <p>Printing the <code>Raw</code> output from this command:</p> <pre><code>9967e3c6196422a6a97afa4b6fca9f609bb5490b fix: filtering on unsupported prefixes\n1b1f4a725cfe44d5c9bd992be59f1130ed9d9911 docs: create docs using material mkdocs\n</code></pre>"},{"location":"git/log/#filtering-the-log-with-pattern-matching","title":"Filtering the log with pattern matching","text":"<p>Filter the commit log to only contain entries that match any set of patterns (regular expressions) using the <code>WithGrep</code> option:</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// assuming the repository has the current history:\n//  ~ fix: forgot to trim whitespace from patterns\n//  ~ docs: document pattern matching option\n//  ~ feat: filter log with pattern matching\n//  ~ initialized the repository\nlog, err := client.Log(git.WithGrep(\"^docs\", \"matching$\"))\nif err != nil {\nlog.Fatal(\"failed to retrieve log with pattern matching\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre> <p>Printing the <code>Raw</code> output from this command, with matches highlighted for reference only:</p> <pre><code>2d68a506fe7d5148db0a10ea143752991a65c26d docs: document pattern matching option\n5bfd532328ed2e9ea6d3062eb3a331f42468a7e3 feat: filter log with pattern matching\n</code></pre>"},{"location":"git/log/#filter-entries-that-do-not-match","title":"Filter entries that do not match","text":"<p>Combining the <code>WithInvertGrep</code> and <code>WithGrep</code> options will inverse pattern matching and filter on log entries that do not contain any of the provided patterns.</p>"},{"location":"git/log/#filter-entries-that-match-all-patterns","title":"Filter entries that match all patterns","text":"<p>Pattern matching uses <code>or</code> semantics by default, matching on log entries that satisfy any of the defined patterns. You can change this behavior to match against all patterns using <code>and</code> semantics with the <code>WithMatchAll</code> option.</p>"},{"location":"git/pull/","title":"Pulling the latest changes from a Remote","text":"<p> Git Documentation</p> <p>Pull all changes from a remote repository into the current branch. Ensures the existing repository keeps track of remote changes and stays in sync.</p>"},{"location":"git/pull/#pull-the-latest-changes-from-the-current-branch","title":"Pull the latest changes from the current Branch","text":"<p>Calling <code>Pull</code> will attempt to sync the current branch with its counterpart from the remote:</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// a new file was added to the hierarchy at the remote:\n//  &gt; folder\n//    &gt; c.txt\nout, err := client.Pull()\nif err != nil {\nlog.Fatal(\"failed to pull latest changes from remote\")\n}\nfmt.Println(out)\n}\n</code></pre> <p>Printing the output from this command:</p> <pre><code>remote: Enumerating objects: 5, done.\nremote: Counting objects: 100% (5/5), done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), 300 bytes | 150.00 KiB/s, done.\nFrom /Users/paulthomas/dev/./gitrepo\n   703a6c9..8e87f78  main       -&gt; origin/main\nUpdating 703a6c9..8e87f78\nFast-forward\n folder/c.txt | 1 +\n 1 file changed, 1 insertion(+)\n create mode 100644 folder/c.txt\n</code></pre>"},{"location":"git/push/","title":"Pushing the latest changes to a Remote","text":"<p> Git Documentation</p> <p>Push all local repository changes back to the remote, ensuring all references are tracked and both instances are in sync.</p>"},{"location":"git/push/#push-committed-changes-back-to-the-remote","title":"Push committed changes back to the Remote","text":"<p>Calling <code>Push</code> will attempt to push all locally committed changes back to the remote for the current branch:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// all changes have been staged and committed locally\n_, err := client.Push()\nif err != nil {\nlog.Fatal(\"failed to push committed changes to the remote\")\n}\n}\n</code></pre>"},{"location":"git/push/#push-the-created-tag-back-to-the-remote","title":"Push the created tag back to the Remote","text":"<p>Calling <code>PushTag</code> will attempt to push the newly created tag back to the remote:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// tag 0.1.0 has been created and is tracked locally\n_, err := client.PushTag(\"0.1.0\")\nif err != nil {\nlog.Fatal(\"failed to push tag 0.1.0 to the remote\")\n}\n}\n</code></pre>"},{"location":"git/stage/","title":"Staging changes within a Repository","text":"<p> Git Documentation</p> <p>Stage changes to a particular file or folder within the current repository for inclusion within the next commit. Staging is a prerequisite to committing and pushing changes back to the repository remote.</p>"},{"location":"git/stage/#staging-all-changes","title":"Staging all changes","text":"<p>By default, all files (<code>tracked</code> and <code>untracked</code>) within the current repository are staged automatically unless explicitly ignored through a <code>.gitignore</code> file:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// create multiple files within the following hierarchy:\n//  &gt; a.txt\n//  &gt; b.txt\n_, err := client.Stage()\nif err != nil {\nlog.Fatal(\"failed to stage all files\")\n}\n}\n</code></pre> <p>And to verify the staged changes:</p> <pre><code>$ git status --porcelain\n\nA  a.txt\nA  b.txt\n</code></pre>"},{"location":"git/stage/#staging-a-file-or-folder","title":"Staging a file or folder","text":"<p>Cherry-picking the staging of files and folders is accomplished using the <code>WithPathSpecs</code> option:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// create multiple files within the following hierarchy:\n//  &gt; root.txt\n//  &gt; folder\n//    &gt; a.txt\n//    &gt; b.txt\n_, err := client.Stage(git.WithPathSpecs(\"root.txt\", \"folder/a.txt\"))\nif err != nil {\nlog.Fatal(\"failed to stage files\")\n}\n}\n</code></pre> <p>And to verify the staged changes:</p> <pre><code>$ git status --porcelain\n\nA  folder/a.txt\n?? folder/b.txt\nA  root.txt\n</code></pre>"},{"location":"git/tag/","title":"Tagging a Repositories History","text":"<p> Git Documentation</p> <p>Tag a specific time point within a repository's history and push it to the configured remote. Tagging comes in two flavors, a <code>lightweight</code> and <code>annotated</code> tag. The main difference being an annotated tag is treated as a complete object within git and must include a message (or annotation). When querying the git history, an annotated tag will contain details such as the author and its GPG signature, if signed.</p> <p>Gitz supports both tags but defaults to creating the lightweight variant unless instructed.</p>"},{"location":"git/tag/#creating-a-lightweight-tag","title":"Creating a Lightweight Tag","text":"<p>Calling <code>Tag</code> with a valid name<sup>1</sup> will tag the repository with a lightweight tag:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Tag(\"0.1.0\")\nif err != nil {\nlog.Fatal(\"failed to tag repository with version 0.1.0\")\n}\n}\n</code></pre> Do you know the git tag naming restrictions? <ol> <li>Tags cannot begin, end with, or contain multiple consecutive <code>/</code> characters.</li> <li>Tags cannot contain any of the following characters: <code>\\ ? ~ ^ : * [ @</code></li> <li>Tags cannot contain a space <code></code>.</li> <li>Tags cannot end with a dot <code>.</code> or contain two consecutive dots <code>..</code> anywhere within them.</li> </ol>"},{"location":"git/tag/#creating-an-annotated-tag","title":"Creating an Annotated Tag","text":"<p>Use the <code>WithAnnotation</code> option to switch to annotated tag creation mode:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Tag(\"0.1.0\", git.WithAnnotation(\"created tag 0.1.0\"))\nif err != nil {\nlog.Fatal(\"failed to tag repository with version 0.1.0\")\n}\n}\n</code></pre> <p>If you were to inspect the annotated tag, details about the author are now included:</p> <pre><code>$ git show 0.1.0\n\ntag 0.1.0\nTagger: Purple Clay &lt;**********(at)*******&gt;\nDate:   Mon Feb 20 05:58:55 2023 +0000\n\ncreated tag 0.1.0\n\n... # (1)!\n</code></pre> <ol> <li>The associated commit was replaced with a <code>...</code> for brevity</li> </ol> <ol> <li> <p>Gitz defers the validation of a tag name to the git client. Any error is captured and returned back to the caller\u00a0\u21a9</p> </li> </ol>"},{"location":"install/package/","title":"Installing the Package","text":"<p>Use <code>go get</code> to pull the <code>gitz</code> package as a dependency within your <code>go.mod</code> file:</p> <pre><code>go get github.com/purpleclay/gitz\n</code></pre> <p>Then to get started, import the package into your project:</p> <pre><code>import git \"github.com/purpleclay/gitz\"\n</code></pre> <p>And that's it!</p>"},{"location":"testing/git-test/","title":"Testing your Interactions with Git","text":"<p><code>gitz</code> includes a <code>gittest</code> package that enables interactions with Git to be unit tested within your projects. Add the following import to any of your test files to get started:</p> <pre><code>import \"github.com/purpleclay/gitz/gittest\"\n</code></pre>"},{"location":"testing/git-test/#building-a-test-repository","title":"Building a test repository","text":"<p> Experimental</p> <p>Only a single line of code is needed to initialize a test repository. And don't worry; it gets deleted after test execution.</p> <pre><code>package git_test\nimport (\n\"testing\"\ngit \"github.com/purpleclay/gitz\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepository(t *testing.T) {\ngittest.InitRepository(t)\nclient, _ := git.NewClient()\nrepo, _ := client.Repository()\nassert.Equal(t, \"main\", repo.DefaultBranch)\n}\n</code></pre> <p>Where <code>gittest</code> shines is in its ability to customize a repository during initialization through a set of options.</p>"},{"location":"testing/git-test/#with-a-commit-log","title":"With a commit log","text":"<p>Initialize a repository with a predefined log by using the <code>WithLog</code> option. It can contain both commit messages and lightweight tags and is written to the repository in reverse chronological order. The expected format is equivalent to the output from the git command:</p> <p><code>git log --pretty='format:%d %s'</code>.</p> <pre><code>package git_test\nimport (\n\"testing\"\ngit \"github.com/purpleclay/gitz\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepositoryWithLog(t *testing.T) {\nlog := `(tag: 0.1.0) feat: this is a brand new feature\ndocs: write amazing material mkdocs documentation\nci: include github release workflow`\ngittest.InitRepository(t, gittest.WithLog(log))\nclient, _ := git.NewClient()\nrepoLog, _ := client.Log()\nassert.Equal(t, \"feat: this is a brand new feature\",\nrepoLog.Commits[0].Message)\nassert.Equal(t, \"docs: write amazing material mkdocs documentation\",\nrepoLog.Commits[1].Message)\nassert.Equal(t, \"ci: include github release workflow\",\nrepoLog.Commits[2].Message)\n}\n</code></pre>"},{"location":"testing/git-test/#with-a-remote-log","title":"With a remote log","text":"<p>Initialize the remote origin of a repository with a predefined log using the <code>WithRemoteLog</code> option. Ideal for simulating a delta between the current log and its remote counterpart.</p> <pre><code>package git_test\nimport (\n\"testing\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepositoryRemoteLog(t *testing.T) {\nlog := \"(main, origin/main) chore: testing remote log\"\ngittest.InitRepository(t, gittest.WithRemoteLog(log))\nrequire.NotEqual(t, gittest.LastCommit(t).Message,\n\"chore: testing remote log\")\nclient, _ := git.NewClient()\n_, err := client.Pull()\nrequire.NoError(t, err)\nassert.Equal(t, gittest.LastCommit(t).Message,\n\"chore: testing remote log\")\n}\n</code></pre>"},{"location":"testing/git-test/#with-untracked-files","title":"With untracked files","text":"<p>Create a set of untracked files within a repository using the <code>WithFiles</code> option. File paths can be fully qualified or relative to the repository root. Each created file will contain a sample of <code>lorem ipsum</code> text.</p> <pre><code>package git_test\nimport (\n\"testing\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepositoryWithFiles(t *testing.T) {\ngittest.InitRepository(t, gittest.WithFiles(\"a.txt\", \"dir/b.txt\"))\nstatus := gittest.PorcelainStatus(t)\nassert.Equal(t, \"?? a.txt\", status[0])\nassert.Equal(t, \"?? dir/\", status[1])\n}\n</code></pre>"},{"location":"testing/git-test/#with-staged-files","title":"With staged files","text":"<p>Create a set of staged (or tracked) files within a repository using the <code>WithStagedFiles</code> option.</p> <pre><code>package git_test\nimport (\n\"testing\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepositoryWithStagedFiles(t *testing.T) {\ngittest.InitRepository(t,\ngittest.WithStagedFiles(\"a.txt\", \"dir/b.txt\"))\nstatus := gittest.PorcelainStatus(t)\nassert.Equal(t, \"A  a.txt\", status[0])\nassert.Equal(t, \"A  dir/b.txt\", status[1])\n}\n</code></pre>"},{"location":"testing/git-test/#with-local-commits","title":"With local commits","text":"<p>Generate a set of local empty commits, ready to be pushed back to the remote, with the <code>WithLocalCommits</code> option. Generated Commits will be in chronological order.</p> <pre><code>package git_test\nimport (\n\"testing\"\ngit \"github.com/purpleclay/gitz\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepositoryWithLocalCommits(t *testing.T) {\ncommits := []string{\n\"docs: my first local commit\",\n\"fix: my second local commit\",\n\"feat: my third local commit\",\n}\ngittest.InitRepository(t, gittest.WithLocalCommits(commits...))\nclient, _ := git.NewClient()\nlog, _ := client.Log()\nassert.Equal(t, \"feat: my third local commit\", log.Commits[0].Message)\nassert.Equal(t, \"fix: my second local commit\", log.Commits[1].Message)\nassert.Equal(t, \"docs: my first local commit\", log.Commits[2].Message)\n}\n</code></pre>"},{"location":"testing/git-test/#with-clone-depth","title":"With clone depth","text":"<p>Shallow clone a repository by truncating its history to a set depth.</p> <pre><code>package git_test\nimport (\n\"testing\"\ngit \"github.com/purpleclay/gitz\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepositoruWithCloneDepth(t *testing.T) {\nlog := `(tag: 0.1.0) feat: this is a brand new feature\ndocs: write amazing material mkdocs documentation\nci: include github release workflow`\ngittest.InitRepository(t,\ngittest.WithLog(log), gittest.WithCloneDepth(1))\nclient, _ := git.NewClient()\nrepoLog, _ := client.Log()\nrequire.Len(t, repoLog, 1)\nassert.Equal(t, \"feat: this is a brand new feature\",\nrepoLog.Commits[0].Message)\n}\n</code></pre>"},{"location":"testing/git-test/#option-initialization-order","title":"Option initialization order","text":"<p>You can use any combination of options during repository initialization, but a strict order is applied.</p> <ol> <li><code>WithLog</code>: log history imported, both local and remote are in sync.</li> <li><code>WithCloneDepth</code>: shallow clone at the required depth.</li> <li><code>WithRemoteLog</code>: remote log history imported, creating a delta between local and remote.</li> <li><code>WithLocalCommits</code>: local commits created and not pushed back to remote.</li> <li><code>WithFiles</code> and <code>WithStagedFiles</code>: files generated and staged if needed.</li> </ol>"}]}