{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Gitz","text":"<p>Write fluent interactions to Git using the <code>gitz</code> library. Programmatically crafting git commands becomes a breeze! Verify your code using the inbuilt testing framework.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2023 Purple Clay</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"git/checkout/","title":"Checking out a branch","text":"<p> Git Documentation</p> <p>Switch from the default branch of a repository (working directory) to a new or existing one, syncing any file changes. All future actions are associated with this branch.</p>"},{"location":"git/checkout/#context-aware-checking-out","title":"Context-aware checking out","text":"<p>During a checkout, <code>gitz</code> inspects the repository for the existence of a branch and intelligently switches between creating a new one or checking out the existing reference.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nout, err := client.Checkout(\"a-new-branch\")\nif err != nil {\nlog.Fatal(\"failed to checkout branch\")\n}\nfmt.Println(out)\n}\n</code></pre> <p>If you were to print the output from the command, you would see a branch creation:</p> <pre><code>Switched to a new branch 'a-new-branch'\n</code></pre> <p>If you check out a branch that already exists, you will see a different output:</p> <pre><code>Switched to branch 'existing-branch'\nYour branch is up to date with 'origin/existing-branch'.\n</code></pre>"},{"location":"git/checks/","title":"Git checks and how to use them","text":"<p><code>gitz</code> comes with a series of inbuilt checks for inspecting the environment and current repository.</p>"},{"location":"git/checks/#checking-for-the-existence-of-a-git-client","title":"Checking for the existence of a Git Client","text":"<p>When creating a new client, <code>gitz</code> will check for the existence of git using the <code>PATH</code> environment variable. An error is returned if no client exists.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, err := git.NewClient()\nif err != nil {\nlog.Fatal(err.Error())\n}\nfmt.Println(client.Version())\n}\n</code></pre>"},{"location":"git/checks/#checking-the-integrity-of-a-repository","title":"Checking the integrity of a Repository","text":"<p>Check the integrity of a repository by running a series of tests and capturing the results for inspection.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nrepo, err := client.Repository()\nif err != nil {\nlog.Fatal(\"failed to check the current repository\")\n}\nfmt.Printf(\"Default Branch: %s\\n\", repo.DefaultBranch)\nfmt.Printf(\"Detached Head:  %t\\n\", repo.DetachedHead)\nfmt.Printf(\"Origin:         %s\\n\", repo.Origin)\nfmt.Printf(\"Remotes:        %#v\\n\", repo.Remotes)\nfmt.Printf(\"Root Directory: %s\\n\", repo.RootDir)\nfmt.Printf(\"Shallow Clone:  %t\\n\", repo.ShallowClone)\n}\n</code></pre> <p>Example output when checking the integrity of a repository cloned within a CI system:</p> <pre><code>Default Branch: main\nDetached Head:  true\nOrigin:         git@github.com:purpleclay/gitz.git\nRemotes:        map[string]string{\"origin\":\"git@github.com:purpleclay/gitz.git\"}\nRoot Directory: /dev/github.com/purpleclay/gitz\nShallow Clone:  false\n</code></pre>"},{"location":"git/clone/","title":"Cloning a repository","text":"<p> Git Documentation</p> <p>Clone a repository by its provided URL into a newly created directory and check out an initial branch forked from the cloned repository\u2019s default branch.</p>"},{"location":"git/clone/#clone-everything","title":"Clone everything","text":"<p>Calling <code>Clone</code> will result in a repository containing all remote-tracking branches, tags, and a complete history.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Clone(\"https://github.com/purpleclay/gitz\")\nif err != nil {\nlog.Fatal(\"failed to clone repository\")\n}\n}\n</code></pre>"},{"location":"git/clone/#with-a-truncated-history","title":"With a truncated history","text":"<p>If a complete git history isn't desirable, a faster approach to cloning is to provide a clone depth using the <code>WithDepth</code> option. This results in a truncated history, better known as a <code>shallow clone</code>. Great for large established repositories.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// A repository exists with the following commits:\n// &gt; feat: add support for shallow cloning\n// &gt; initialized repository\n_, err := client.Clone(\"https://github.com/purpleclay/gitz\",\ngit.WithDepth(1))\nif err != nil {\nlog.Fatal(\"failed to clone repository\")\n}\nrepoLog, err := client.Log()\nif err != nil {\nlog.Fatal(\"failed to retrieve repository log\")\n}\nfor _, commit := range repoLog.Commits {\nfmt.Println(commit.Message)\n}\n}\n</code></pre> <p>Printing the log results in:</p> <pre><code>feat: add options that can configure the size of the repository during a clone\n</code></pre>"},{"location":"git/clone/#without-tags","title":"Without tags","text":"<p>To further streamline a clone, the <code>WithNoTags</code> option prevents the downloading of tags from the remote.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Clone(\"https://github.com/purpleclay/gitz\",\ngit.WithNoTags())\nif err != nil {\nlog.Fatal(\"failed to clone repository\")\n}\ntags, err := client.Tags()\nif err != nil {\nlog.Fatal(\"failed to retrieve repository tags\")\n}\nif len(tags) == 0 {\nfmt.Println(\"repository has no tags\")\n}\n}\n</code></pre> <p>Printing the output results in:</p> <pre><code>repository has no tags\n</code></pre>"},{"location":"git/clone/#clone-into-a-named-directory","title":"Clone into a named directory","text":"<p>By default, git will always clone the repository into a directory based on the human-friendly part of the clone URL. To clone into a different directory, use the <code>WithDirectory</code> option.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Clone(\"https://github.com/purpleclay/gitz\",\ngit.WithDirectory(\"my-gitz\"))\nif err != nil {\nlog.Fatal(\"failed to clone repository\")\n}\n}\n</code></pre>"},{"location":"git/clone/#clone-a-branch-or-tag","title":"Clone a branch or tag","text":"<p>Git will always clone and checkout the default branch of a repository. To change this behavior, provide a branch or tag reference with the <code>WithCheckoutRef</code> option. The latter results in a <code>detached HEAD</code> where the <code>HEAD</code> of a repository points to a specific commit reference.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Clone(\"https://github.com/purpleclay/gitz\",\ngit.WithCheckoutRef(\"0.1.0\"))\nif err != nil {\nlog.Fatal(\"failed to clone repository\")\n}\n}\n</code></pre>"},{"location":"git/clone/#providing-git-config-at-execution","title":"Providing git config at execution","text":"<p>You can provide git config through the <code>WithCloneConfig</code> option to only take effect during the execution of a <code>Clone</code>, removing the need to change config permanently.</p>"},{"location":"git/commit/","title":"Committing changes to a repository","text":"<p> Git Documentation</p> <p>Create a commit (snapshot of changes) within the current repository and describe those changes with a given log message. A commit will only exist within the local history until pushed back to the repository remote.</p>"},{"location":"git/commit/#commit-a-snapshot-of-repository-changes","title":"Commit a Snapshot of Repository Changes","text":"<p>Calling <code>Commit</code> with a message will create a new commit within the repository:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// stage all changes to files and folders\n_, err := client.Commit(\"feat: a brand new feature\")\nif err != nil {\nlog.Fatal(\"failed to commit latest changes within repository\")\n}\n}\n</code></pre> <p>And to verify its creation:</p> <pre><code>$ git log -n1\n\ncommit 703a6c9bc9ee91d0c226b169b131670fb92d9a0a (HEAD -&gt; main)\nAuthor: Purple Clay &lt;**********(at)*******&gt;\nDate:   Mon Feb 20 20:43:49 2023 +0000\n\n    feat: a brand new feature\n</code></pre>"},{"location":"git/commit/#allowing-an-empty-commit","title":"Allowing an empty commit","text":"<p>You can create empty commits without staging any files using the <code>WithAllowEmpty</code> option.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nclient.Commit(\"no files are staged here\", git.WithAllowEmpty())\n}\n</code></pre>"},{"location":"git/commit/#signing-a-commit-using-gpg","title":"Signing a commit using GPG","text":"<p>Any commit to a repository can be GPG signed by an author to prove its authenticity through GPG verification. By setting the <code>commit.gpgSign</code> and <code>user.signingKey</code> git config options, GPG signing, can become an automatic process. <code>gitz</code> provides options to control this process and manually overwrite existing settings per commit.</p>"},{"location":"git/commit/#sign-an-individual-commit","title":"Sign an individual commit","text":"<p>If the <code>commit.gpgSign</code> git config setting is not enabled; you can selectively GPG sign a commit using the <code>WithGpgSign</code> option.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Commit(\"no files are staged here\",\ngit.WithAllowEmpty(),\ngit.WithGpgSign())\nif err != nil {\nlog.Fatal(\"failed to gpg sign commit with user.signingKey\")\n}\n}\n</code></pre>"},{"location":"git/commit/#select-a-gpg-signing-key","title":"Select a GPG signing key","text":"<p>If multiple GPG keys exist, you can cherry-pick a key during a commit using the <code>WithGpgSigningKey</code> option, overriding the <code>user.signingKey</code> git config setting, if set.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Commit(\"no files are staged here\",\ngit.WithAllowEmpty(),\ngit.WithGpgSigningKey(\"E5389A1079D5A52F\"))\nif err != nil {\nlog.Fatal(\"failed to gpg sign commit with provided public key\")\n}\n}\n</code></pre>"},{"location":"git/commit/#prevent-a-commit-from-being-signed","title":"Prevent a commit from being signed","text":"<p>You can disable the GPG signing of a commit by using the <code>WithNoGpgSign</code> option, overriding the <code>commit.gpgSign</code> git config setting, if set.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nclient.Commit(\"prevent commit from being signed\",\ngit.WithAllowEmpty(),\ngit.WithNoGpgSign())\n}\n</code></pre>"},{"location":"git/commit/#providing-git-config-at-execution","title":"Providing git config at execution","text":"<p>You can provide git config through the <code>WithCommitConfig</code> option to only take effect during the execution of a <code>Commit</code>, removing the need to change config permanently.</p>"},{"location":"git/config/","title":"Managing your git config","text":"<p> Git Documentation</p> <p>Manage settings within your local git config, changing the behavior of the git client.</p>"},{"location":"git/config/#retrieve-all-settings","title":"Retrieve all settings","text":"<p>Retrieve all git config for the current repository using <code>Config</code>.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\ncfg, err := client.Config()\nif err != nil {\nlog.Fatal(\"failed to retrieve config for current repository\")\n}\nfmt.Println(cfg[\"user.name\"])\n}\n</code></pre> <p>The value for the config setting would be:</p> <pre><code>purpleclay\n</code></pre>"},{"location":"git/config/#retrieve-a-batch-of-settings","title":"Retrieve a batch of settings","text":"<p>A batch of settings can be retrieved using <code>ConfigL</code> (local), <code>ConfigS</code> (system), or <code>ConfigG</code> (global). A partial retrieval is not supported and will fail if any are missing. All values for a setting are retrieved and ordered by the latest.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\ncfg, err := client.ConfigL(\"user.name\", \"user.email\")\nif err != nil {\nlog.Fatal(\"failed to retrieve local config settings\")\n}\nfmt.Println(cfg[\"user.name\"][0])\nfmt.Println(cfg[\"user.email\"][0])\n}\n</code></pre> <p>The value for each config setting would be:</p> <pre><code>purpleclay\n**********************\n</code></pre>"},{"location":"git/config/#update-a-batch-of-settings","title":"Update a batch of settings","text":"<p>You can update multiple settings in a batch using <code>ConfigSetL</code> (local), <code>ConfigSetS</code> (system), or <code>ConfigSetG</code> (global). Pre-validation of config paths improves the chance of a successful update, but a partial batch may occur upon failure.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nerr := client.ConfigSetL(\"custom.setting1\", \"value\",\n\"custom.setting2\", \"value\")\nif err != nil {\nlog.Fatal(\"failed to set local config settings\")\n}\n}\n</code></pre>"},{"location":"git/log/","title":"Inspecting the commit log of a repository","text":"<p> Git Documentation</p> <p>Retrieve the commit log of a repository in an easy-to-parse format.</p>"},{"location":"git/log/#view-the-entire-log","title":"View the entire log","text":"<p>Calling <code>Log</code> without any options will retrieve the entire repository log from the current branch. A default formatting of <code>--pretty=oneline --no-decorate --no-color</code> is applied by <code>gitz</code> during log retrieval:</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nlog, err := client.Log()\nif err != nil {\nlog.Fatal(\"failed to retrieve repository log\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre> <p>Printing the <code>Raw</code> output from this command:</p> <pre><code>99cb396148cff7db435cebb9a8ea95a11b5658e1 fix: input string parsing error\ne8b67f90c613340fd61392fda03181d86a7febbe ci: extend existing build workflow\nc90e819baa6ddc212811924c51256e65f53d4c32 docs: create mkdocs documentation\n1635f10b81a810833b163793e6ef902d52a89789 feat: add first feature to library\na09348464773e99dbc94a5494b5b83b253c18019 initialized repository\n</code></pre> <p>By default, <code>gitz</code> parses the log into a structured output accessible through the <code>Commits</code> property. This structure contains each commit's associated <code>Hash</code>, <code>Abbreviated Hash</code>, and <code>Message</code>.</p>"},{"location":"git/log/#return-only-raw-output-from-the-log","title":"Return only raw output from the log","text":"<p>Use the <code>WithRawOnly</code> option to skip parsing of the log into the structured <code>Commits</code> property, improving performance. Perfect if you want to carry out any custom processing.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nlog, err := client.Log(git.WithRawOnly())\nif err != nil {\nlog.Fatal(\"failed to retrieve repository log\")\n}\nfmt.Println(log.Commits)\n}\n</code></pre> <p>Printing the <code>Commits</code> property should now be an empty slice:</p> <pre><code>[]\n</code></pre>"},{"location":"git/log/#view-the-log-from-a-point-in-time","title":"View the log from a point in time","text":"<p>When retrieving the log history, the <code>WithRef</code> option provides a starting point other than HEAD (most recent commit). A reference can be a <code>Commit Hash</code>, <code>Branch Name</code>, or <code>Tag</code>. Output from this option will be a shorter, fine-tuned log.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nlog, err := client.Log(git.WithRef(\"0.1.0\"))\nif err != nil {\nlog.Fatal(\"failed to retrieve log for tag 0.1.0\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre>"},{"location":"git/log/#view-a-snapshot-of-the-log","title":"View a snapshot of the log","text":"<p>The <code>WithRefRange</code> option provides a start and end point for retrieving a snapshot of the log history between two points in time. A reference can be a <code>Commit Hash</code>, <code>Branch Name</code>, or <code>Tag</code>. Output from this option will be a shorter, fine-tuned log.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nlog, err := client.Log(git.WithRefRange(\"0.2.0\", \"0.1.0\"))\nif err != nil {\nlog.Fatal(\"failed to retrieve log between tags 0.2.0 and 0.1.0\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre>"},{"location":"git/log/#view-the-log-of-any-files-or-folders","title":"View the log of any files or folders","text":"<p>Fine-tune the log history further with the <code>WithPaths</code> option. Providing a set of relative paths to any files and folders within the repository will include only commits related to their history.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// commits are made to the following files in a newly initialized\n// repository:\n//  &gt; a.txt\n//    ~ fix: typos in file content\n//  &gt; b.txt\n//    ~ chore: restructure file into expected format\n//  &gt; dir1 (b.txt, c.txt)\n//    ~ feat: a brand new feature\nlog, err := client.Log(git.WithPaths(\"a.txt\", \"dir1\"))\nif err != nil {\nlog.Fatal(\"failed to retrieve log using custom paths\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre> <p>Printing the <code>Raw</code> output from this command:</p> <pre><code>d611a22c1a009bd74bc2c691b331b9df38828dae fix: typos in file content\n9b342465255d1a8ec4f5517eef6049e5bcc8fb45 feat: a brand new feature\n</code></pre>"},{"location":"git/log/#resolving-explicit-file-paths","title":"Resolving explicit file paths","text":"<p>Querying the log with explicit paths isn't supported and will return no history. Converting to a relative one can be achieved with the <code>ToRelativePath</code> helper, as it resolves paths against the root working directory of the current repository.</p>"},{"location":"git/log/#cherry-picking-a-section-of-the-log","title":"Cherry-picking a section of the log","text":"<p>Cherry-pick a section of the log by skipping and taking a set number of entries using the respective <code>WithSkip</code> and <code>WithTake</code> options. If combined, skipping has a higher order of precedence:</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// assuming the repository has the current history:\n//  ~ docs: document fix\n//  ~ fix: filtering on unsupported prefixes\n//  ~ docs: create docs using material mkdocs\n//  ~ feat: add new support for filtering based on prefixes\n//  ~ initialized the repository\nlog, err := client.Log(git.WithSkip(1), git.WithTake(2))\nif err != nil {\nlog.Fatal(\"failed to retrieve log using custom paths\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre> <p>Printing the <code>Raw</code> output from this command:</p> <pre><code>9967e3c6196422a6a97afa4b6fca9f609bb5490b fix: filtering on unsupported prefixes\n1b1f4a725cfe44d5c9bd992be59f1130ed9d9911 docs: create docs using material mkdocs\n</code></pre>"},{"location":"git/log/#filtering-the-log-with-pattern-matching","title":"Filtering the log with pattern matching","text":"<p>Filter the commit log to only contain entries that match any set of patterns (regular expressions) using the <code>WithGrep</code> option:</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// assuming the repository has the current history:\n//  ~ fix: forgot to trim whitespace from patterns\n//  ~ docs: document pattern matching option\n//  ~ feat: filter log with pattern matching\n//  ~ initialized the repository\nlog, err := client.Log(git.WithGrep(\"^docs\", \"matching$\"))\nif err != nil {\nlog.Fatal(\"failed to retrieve log with pattern matching\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre> <p>Printing the <code>Raw</code> output from this command, with matches highlighted for reference only:</p> <pre><code>2d68a506fe7d5148db0a10ea143752991a65c26d docs: document pattern matching option\n5bfd532328ed2e9ea6d3062eb3a331f42468a7e3 feat: filter log with pattern matching\n</code></pre>"},{"location":"git/log/#filter-entries-that-do-not-match","title":"Filter entries that do not match","text":"<p>Combining the <code>WithInvertGrep</code> and <code>WithGrep</code> options will inverse pattern matching and filter on log entries that do not contain any of the provided patterns.</p>"},{"location":"git/log/#filter-entries-that-match-all-patterns","title":"Filter entries that match all patterns","text":"<p>Pattern matching uses <code>or</code> semantics by default, matching on log entries that satisfy any of the defined patterns. You can change this behavior to match against all patterns using <code>and</code> semantics with the <code>WithMatchAll</code> option.</p>"},{"location":"git/pull/","title":"Pulling the latest changes from a remote","text":"<p> Git Documentation</p> <p>Pull all changes from a remote into the current working directory. Ensures the existing repository keeps track of changes and stays in sync.</p>"},{"location":"git/pull/#pull-the-latest-changes-from-the-current-branch","title":"Pull the latest changes from the current Branch","text":"<p>Calling <code>Pull</code> will attempt to sync the current branch with its counterpart from the remote:</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// a new file was added to the hierarchy at the remote:\n//  &gt; folder\n//    &gt; c.txt\nout, err := client.Pull()\nif err != nil {\nlog.Fatal(\"failed to pull latest changes from remote\")\n}\nfmt.Println(out)\n}\n</code></pre> <p>Printing the output from this command:</p> <pre><code>remote: Enumerating objects: 5, done.\nremote: Counting objects: 100% (5/5), done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), 300 bytes | 150.00 KiB/s, done.\nFrom /Users/paulthomas/dev/./gitrepo\n   703a6c9..8e87f78  main       -&gt; origin/main\nUpdating 703a6c9..8e87f78\nFast-forward\n folder/c.txt | 1 +\n 1 file changed, 1 insertion(+)\n create mode 100644 folder/c.txt\n</code></pre>"},{"location":"git/pull/#providing-git-config-at-execution","title":"Providing git config at execution","text":"<p>You can provide git config through the <code>WithPullConfig</code> option to only take effect during the execution of a <code>Pull</code>, removing the need to change config permanently.</p>"},{"location":"git/push/","title":"Pushing the latest changes back to a remote","text":"<p> Git Documentation</p> <p>Push all local repository changes back to the remote, ensuring the remote now tracks all references.</p>"},{"location":"git/push/#pushing-locally-committed-changes","title":"Pushing locally committed changes","text":"<p>Calling <code>Push</code> without any options will attempt to push all locally committed changes back to the remote for the current branch:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// all changes have been staged and committed locally\n_, err := client.Push()\nif err != nil {\nlog.Fatal(\"failed to push committed changes to the remote\")\n}\n}\n</code></pre>"},{"location":"git/push/#pushing-all-local-branches","title":"Pushing all local branches","text":"<p>To push changes spread across multiple branches back to the remote in a single atomic operation, use the <code>WillAllBranches</code> option:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// modifications are made to multiple files across two\n// different branches\n//\n// b: new-feature\n//  &gt; client.go\n// b: new-bug-fix\n//  &gt; parser.go\n_, err := client.Push(git.WithAllBranches())\nif err != nil {\nlog.Fatal(\"failed to stage files\")\n}\n}\n</code></pre>"},{"location":"git/push/#pushing-all-local-tags","title":"Pushing all local tags","text":"<p>All locally created tags can also be pushed back to the remote in a single atomic operation using the <code>WithAllTags</code> option:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// multiple tags are created locally, 1.0.0 and v1\n_, err := client.Push(git.WithAllTags())\nif err != nil {\nlog.Fatal(\"failed to stage files\")\n}\n}\n</code></pre>"},{"location":"git/push/#cherry-pick-what-is-pushed-to-the-remote","title":"Cherry-pick what is pushed to the remote","text":"<p>The <code>WithRefSpecs</code> option provides greater freedom to cherry-pick locally created references (branches and tags) and push them back to the remote. A reference can be as simple as a name or as explicit as providing a source (local) to destination (remote) mapping. Please read the official git specification on how to construct refspecs.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// new branch and tag are created locally\n_, err := client.Push(git.WithRefSpecs(\"0.1.0\", \"new-branch\"))\nif err != nil {\nlog.Fatal(\"failed to stage files\")\n}\n}\n</code></pre>"},{"location":"git/push/#push-options","title":"Push options","text":"<p>Support the transmission of arbitrary strings to the remote server using the <code>WithPushOptions</code> option.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// all changes have been staged and committed locally\n_, err := client.Push(git.WithPushOptions(\"ci.skip=true\"))\nif err != nil {\nlog.Fatal(\"failed to push committed changes to the remote\")\n}\n}\n</code></pre>"},{"location":"git/push/#deleting-references-from-the-remote","title":"Deleting references from the remote","text":"<p>Delete any number of references from the remote by using the <code>WithDeleteRefSpecs</code> option.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// a tag and branch have been deleted locally\n_, err := client.Push(git.WithDeleteRefSpecs(\"branch\", \"0.1.0\"))\nif err != nil {\nlog.Fatal(\"failed to delete references from the remote\")\n}\n}\n</code></pre>"},{"location":"git/push/#providing-git-config-at-execution","title":"Providing git config at execution","text":"<p>You can provide git config through the <code>WithPushConfig</code> option to only take effect during the execution of a <code>Push</code>, removing the need to change config permanently.</p>"},{"location":"git/show/","title":"Inspect an object within a repository","text":"<p> Git Documentation</p> <p>Retrieve detailed information about an object within a repository by its unique reference.</p>"},{"location":"git/show/#inspect-a-tag","title":"Inspect a tag","text":"<p>Detailed information about a tag, and its associated commit, can be retrieved from a repository by passing its reference to <code>ShowTags</code>. The GPG signature of the commit is also retrieved if present.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"time\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// Querying a tag from the gpg-import project\ntags, _ := client.ShowTags(\"0.3.2\")\ntag := tags[0]\nif tag.Annotation != nil {\nfmt.Printf(\"Tagger:      %s &lt;%s&gt;\\n\",\ntag.Annotation.Tagger.Name, tag.Annotation.Tagger.Email)\nfmt.Printf(\"TaggerDate:  %s\\n\",\ntag.Annotation.TaggerDate.Format(time.RubyDate))\nfmt.Printf(\"Message:     %s\\n\\n\", tag.Annotation.Message)\n}\nfmt.Printf(\"Author:      %s &lt;%s&gt;\\n\",\ntag.Commit.Author.Name, tag.Commit.Author.Email)\nfmt.Printf(\"AuthorDate:  %s\\n\",\ntag.Commit.AuthorDate.Format(time.RubyDate))\nfmt.Printf(\"Commit:      %s &lt;%s&gt;\\n\",\ntag.Commit.Committer.Name, tag.Commit.Committer.Email)\nfmt.Printf(\"CommitDate:  %s\\n\",\ntag.Commit.CommitterDate.Format(time.RubyDate))\nfmt.Printf(\"Message:     %s\\n\\n\", tag.Commit.Message)\nif tag.Commit.Signature != nil {\nfmt.Printf(\"Fingerprint: %s\\n\", tag.Commit.Signature.Fingerprint)\n}\n}\n</code></pre> <pre><code>Tagger:      purpleclay &lt;purpleclaygh@gmail.com&gt;\nTaggerDate:  Thu Jun 29 07:05:18 +0100 2023\nMessage:     chore: tagged for release 0.3.2\n\nAuthor:      Purple Clay &lt;purpleclaygh@gmail.com&gt;\nAuthorDate:  Thu Jun 29 06:40:51 +0100 2023\nCommit:      GitHub &lt;noreply@github.com&gt;\nCommitDate:  Thu Jun 29 06:40:51 +0100 2023\nMessage:     fix: imported gpg key fails to sign when no tty is present (#33)\nFingerprint: 4AEE18**********\n</code></pre>"},{"location":"git/show/#inspect-a-commit","title":"Inspect a commit","text":"<p>Retrieve information about a specific commit by passing its reference to <code>ShowCommits</code>. Including its GPG signature, if present.</p>"},{"location":"git/show/#inspect-a-tree","title":"Inspect a tree","text":"<p>Call <code>ShowTrees</code> to retrieve a listing of all files and directories within a specific tree index of a repository.</p> <pre><code>package main\nimport (\n\"fmt\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// Query the gittest directory tree within gitz\ntree, _ := client.ShowTrees(\"ad4a68f6628ba9a6c367fe213eb8136fdb95ebcd\")\nfor _, entry := range tree[0].Entries {\nfmt.Printf(\"%s\\n\", entry)\n}\n}\n</code></pre> <pre><code>log.go\nlog_test.go\nrepository.go\nrepository_test.go\n</code></pre>"},{"location":"git/show/#inspect-a-blob","title":"Inspect a blob","text":"<p>Retrieve the contents of a file (blob) from a repository by passing its reference to <code>ShowBlobs</code>.</p>"},{"location":"git/stage/","title":"Staging changes within a repository","text":"<p> Git Documentation</p> <p>Stage changes to a particular file or folder within the current repository for inclusion within the next commit. Staging is a prerequisite to committing and pushing changes back to the repository remote.</p>"},{"location":"git/stage/#staging-all-changes","title":"Staging all changes","text":"<p>By default, all files (<code>tracked</code> and <code>untracked</code>) within the current repository are staged automatically unless explicitly ignored through a <code>.gitignore</code> file:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// create multiple files within the following hierarchy:\n//  &gt; a.txt\n//  &gt; b.txt\n_, err := client.Stage()\nif err != nil {\nlog.Fatal(\"failed to stage all files\")\n}\n}\n</code></pre> <p>And to verify the staged changes:</p> <pre><code>$ git status --porcelain\n\nA  a.txt\nA  b.txt\n</code></pre>"},{"location":"git/stage/#staging-a-file-or-folder","title":"Staging a file or folder","text":"<p>Cherry-picking the staging of files and folders is accomplished using the <code>WithPathSpecs</code> option:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// create multiple files within the following hierarchy:\n//  &gt; root.txt\n//  &gt; folder\n//    &gt; a.txt\n//    &gt; b.txt\n_, err := client.Stage(git.WithPathSpecs(\"root.txt\", \"folder/a.txt\"))\nif err != nil {\nlog.Fatal(\"failed to stage files\")\n}\n}\n</code></pre> <p>And to verify the staged changes:</p> <pre><code>$ git status --porcelain\n\nA  folder/a.txt\n?? folder/b.txt\nA  root.txt\n</code></pre>"},{"location":"git/status/","title":"Inspecting the status of a repository","text":"<p> Git Documentation</p> <p>Identify if any differences exist between the git staging area (known as the index) and the latest commit.</p>"},{"location":"git/status/#porcelain-status","title":"Porcelain status","text":"<p>To retrieve a parseable list of changes within a repository, call <code>PorcelainStatus</code>. Changes are listed using the porcelain V1 format, consisting of a two-character indicator followed by a path to the identified change.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// Add some files:\n//  new.txt\n//  staged.txt\nstatus, _ := client.PorcelainStatus()\nfor _, s := range status {\nfmt.Printf(\"%s\\n\", s)\n}\n}\n</code></pre> <pre><code>?? new.txt\nA  staged.txt\n</code></pre>"},{"location":"git/status/#supported-indicators","title":"Supported indicators","text":"<p>A two-character indicator, <code>' A'</code>, denotes the status of a file. It should be read as its status within the index, followed by its status within the working tree. Staging a file will move it from the working tree to the index, moving the indicator from the right (<code>' A'</code>) to the left (<code>'A '</code>).</p> <pre><code>'A' Added\n'C' Copied\n'D' Deleted\n'!' Ignored\n'M' Modified\n'R' Renamed\n'T' Type Changed (e.g. regular file to symlink)\n'U' Updated\n' ' Unmodified\n'?' Untracked\n</code></pre>"},{"location":"git/status/#check-if-a-repository-is-clean","title":"Check if a repository is clean","text":"<p>Calling <code>Clean</code> will return <code>true</code> if a repository has no outstanding changes.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nclean, _ := client.Clean()\nfmt.Printf(\"Is Clean: %t\\n\", clean)\n}\n</code></pre> <pre><code>Is Clean: true\n</code></pre>"},{"location":"git/tag/","title":"Creating, listing, and deleting tags","text":"<p> Git Documentation</p> <p>Manage tag creation, deletion, and retrieval within the current repository.</p>"},{"location":"git/tag/#creating-a-tag","title":"Creating a tag","text":"<p>Tag a specific time point within a repository's history ready for pushing back to the configured remote. Tagging comes in two flavors, a <code>lightweight</code> and <code>annotated</code> tag. The main difference being an annotated tag is treated as a complete object within git and must include a message (or annotation). When querying the git history, an annotated tag will contain details such as the author and its GPG signature, if signed.</p> <p>Gitz supports both tags but defaults to creating the lightweight variant unless instructed.</p>"},{"location":"git/tag/#creating-a-lightweight-tag","title":"Creating a lightweight tag","text":"<p>Calling <code>Tag</code> with a valid name<sup>1</sup> will tag the repository with a lightweight tag:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Tag(\"0.1.0\")\nif err != nil {\nlog.Fatal(\"failed to tag repository with version 0.1.0\")\n}\n}\n</code></pre> Do you know the git tag naming restrictions? <ol> <li>Tags cannot begin, end with, or contain multiple consecutive <code>/</code> characters.</li> <li>Tags cannot contain any of the following characters: <code>\\ ? ~ ^ : * [ @</code></li> <li>Tags cannot contain a space <code></code>.</li> <li>Tags cannot end with a dot <code>.</code> or contain two consecutive dots <code>..</code> anywhere within them.</li> </ol>"},{"location":"git/tag/#creating-an-annotated-tag","title":"Creating an annotated tag","text":"<p>Use the <code>WithAnnotation</code> option to switch to annotated tag creation mode:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Tag(\"0.1.0\", git.WithAnnotation(\"created tag 0.1.0\"))\nif err != nil {\nlog.Fatal(\"failed to tag repository with version 0.1.0\")\n}\n}\n</code></pre> <p>If you were to inspect the annotated tag, details about the author are now included:</p> <pre><code>$ git show 0.1.0\n\ntag 0.1.0\nTagger: Purple Clay &lt;**********(at)*******&gt;\nDate:   Mon Feb 20 05:58:55 2023 +0000\n\ncreated tag 0.1.0\n\nassociated commit message\n</code></pre>"},{"location":"git/tag/#retrieving-all-tags","title":"Retrieving all tags","text":"<p>Calling <code>Tags</code> will retrieve all tags from the current repository in ascending lexicographic order:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// Repository contains tags 0.9.0, 0.9.1, 0.10.0 and 0.11.0\ntags, err := client.Tags()\nif err != nil {\nlog.Fatal(\"failed to retrieve local repository tags\")\n}\nfor _, tag := range tags {\nfmt.Println(tag)\n}\n}\n</code></pre> <p>The resulting output would be:</p> <pre><code>0.10.0\n0.11.0\n0.9.0\n0.9.1\n</code></pre>"},{"location":"git/tag/#changing-the-sort-order","title":"Changing the sort order","text":"<p>You can change the default sort order when retrieving tags by using the <code>WithSortBy</code> option. Various sort keys exist, each affecting the overall sort differently. If using multiple sort keys, the last one becomes the primary key. Prefix any key with a <code>-</code> for a descending sort. For convenience <code>gitz</code> provides constants for the most common sort keys:</p> <ul> <li><code>creatordate</code>: sort by the creation date of the associated commit.</li> <li><code>refname</code>: sort by the tags reference name in lexicographic order (default).</li> <li><code>taggerdate</code>: sort by the tags creation date.</li> <li><code>version:refname</code>: interpolates the tag as a version number and sorts.</li> </ul> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// Repository contains tags 0.9.0, 0.9.1, 0.10.0 and 0.11.0\ntags, err := client.Tags(git.WithSortBy(git.VersionDesc))\nif err != nil {\nlog.Fatal(\"failed to sort local repository tags\")\n}\nfor _, tag := range tags {\nfmt.Println(tag)\n}\n}\n</code></pre> <p>The resulting output would now be:</p> <pre><code>0.11.0\n0.10.0\n0.9.1\n0.9.0\n</code></pre>"},{"location":"git/tag/#filtering-by-pattern","title":"Filtering by pattern","text":"<p>Filter local tags using pattern-based git shell globs with the <code>WithShellGlob</code> option. If using multiple patterns, a tag only needs to match one.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// Repository contains tags 0.8.0, 0.9.0, 1.0.0 and v1\ntags, err := client.Tags(git.WithShellGlob(\"*.*.*\"))\nif err != nil {\nlog.Fatal(\"failed to retrieve local repository tags\")\n}\nfor _, tag := range tags {\nfmt.Println(tag)\n}\n}\n</code></pre> <p>The filtered output would be:</p> <pre><code>0.8.0\n0.9.0\n1.0.0\n</code></pre>"},{"location":"git/tag/#user-defined-filters","title":"User-defined filters","text":"<p>Extend filtering by applying user-defined filters to the list of retrieved tags with the <code>WithFilters</code> option. Execution of filters is in the order defined.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nvar (\nuiFilter = func(tag string) bool {\nreturn strings.HasPrefix(tag, \"ui/\")\n}\nnoVTagsFilter := func(tag string) bool {\nreturn !strings.HasSuffix(tag, \"v1\")\n}\n)\nfunc main() {\nclient, _ := git.NewClient()\n// Repository contains tags ui/1.0.0, ui/v1, backend/1.0.0, backend/v1\ntags, err := client.Tags(git.WithFilters(uiFilter, noVTagsFilter))\nif err != nil {\nlog.Fatal(\"failed to retrieve local repository tags\")\n}\nfor _, tag := range tags {\nfmt.Println(tag)\n}\n}\n</code></pre> <p>The filtered output would be:</p> <pre><code>ui/0.1.0\n</code></pre>"},{"location":"git/tag/#limiting-the-number-of-tags","title":"Limiting the number of tags","text":"<p>Define the maximum number of returned tags through the <code>WithCount</code> option. Limiting is applied as a post-processing step after all other options.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// Repository contains tags 0.1.0, 0.2.0, 0.3.0, 0.4.0\ntags, err := client.Tags(git.WithSortBy(git.VersionDesc),\ngit.WithCount(2))\nif err != nil {\nlog.Fatal(\"failed to retrieve local repository tags\")\n}\nfor _, tag := range tags {\nfmt.Println(tag)\n}\n}\n</code></pre> <p>The limited output would be:</p> <pre><code>0.4.0\n0.3.0\n</code></pre>"},{"location":"git/tag/#deleting-a-tag","title":"Deleting a tag","text":"<p>Call <code>DeleteTag</code> to delete a local tag and sync it with the remote:</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n// Repository contains tag 0.1.0\ntags, err := client.DeleteTag(\"0.1.0\")\nif err != nil {\nlog.Fatal(\"failed to delete tag)\n}\n}\n</code></pre>"},{"location":"git/tag/#only-delete-local-reference","title":"Only delete local reference","text":"<p>To prevent a deletion from being pushed back to the remote, use the <code>WithLocalDelete</code> option.</p>"},{"location":"git/tag/#deleting-multiple-tags","title":"Deleting multiple tags","text":"<p>Call <code>DeleteTags</code> if you need to delete a batch of tags and sync it with the remote. Use the <code>WithLocalDelete</code> option to prevent any deletion from being pushed back to the remote.</p>"},{"location":"git/tag/#signing-a-tag-using-gpg","title":"Signing a tag using GPG","text":"<p>Any tag against a repository can be GPG signed by the tagger to prove its authenticity through GPG verification. By setting the <code>tag.gpgSign</code> and <code>user.signingKey</code> git config options, GPG signing, can become an automatic process. <code>gitz</code> provides options to control this process and manually overwrite existing settings per tag.</p>"},{"location":"git/tag/#annotating-the-signed-tag","title":"Annotating the signed tag","text":"<p>A signed tag must have an annotation. <code>gitz</code> defaults this to <code>created tag &lt;ref&gt;</code>, but you can change this with the <code>WithAnnotation</code> option.</p>"},{"location":"git/tag/#sign-an-individual-tag","title":"Sign an individual tag","text":"<p>If the <code>tag.gpgSign</code> git config setting is not enabled, you can selectively GPG sign a tag using the <code>WithSigned</code> option.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Tag(\"0.1.0\", git.WithSigned())\nif err != nil {\nlog.Fatal(\"failed to gpg sign tag with user.signingKey\")\n}\n}\n</code></pre>"},{"location":"git/tag/#select-a-gpg-signing-key","title":"Select a GPG signing key","text":"<p>If multiple GPG keys exist, you can cherry-pick a key when tagging using the <code>WithSigningKey</code> option, overriding the <code>user.signingKey</code> git config setting, if set.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Tag(\"0.1.0\", git.WithSigningKey(\"E5389A1079D5A52F\"))\nif err != nil {\nlog.Fatal(\"failed to gpg sign tag with provided public key\")\n}\n}\n</code></pre>"},{"location":"git/tag/#prevent-a-tag-from-being-signed","title":"Prevent a tag from being signed","text":"<p>You can disable the GPG signing of a tag by using the <code>WithSkipSigning</code> option, overriding the <code>tag.gpgSign</code> git config setting if set.</p> <pre><code>package main\nimport (\n\"log\"\ngit \"github.com/purpleclay/gitz\"\n)\nfunc main() {\nclient, _ := git.NewClient()\nclient.Tag(\"0.1.0\", git.WithSkipSigning())\n}\n</code></pre>"},{"location":"git/tag/#providing-git-config-at-execution","title":"Providing git config at execution","text":"<p>You can provide git config through the <code>WithTagConfig</code> option to only take effect during the execution of a <code>Tag</code>, removing the need to change config permanently.</p> <ol> <li> <p>Gitz defers the validation of a tag name to the git client. Any error is captured and returned back to the caller\u00a0\u21a9</p> </li> </ol>"},{"location":"install/package/","title":"How to install gitz","text":"<p>Use <code>go get</code> to pull the <code>gitz</code> package as a dependency within your <code>go.mod</code> file:</p> <pre><code>go get github.com/purpleclay/gitz\n</code></pre> <p>Then to get started, import the package into your project:</p> <pre><code>import git \"github.com/purpleclay/gitz\"\n</code></pre> <p>And that's it!</p>"},{"location":"testing/git-test/","title":"Testing your interactions with git","text":"<p><code>gitz</code> includes a <code>gittest</code> package that enables interactions with Git to be unit tested within your projects. Add the following import to any of your test files to get started:</p> <pre><code>import \"github.com/purpleclay/gitz/gittest\"\n</code></pre>"},{"location":"testing/git-test/#building-a-test-repository","title":"Building a test repository","text":"<p>Only a single line of code is needed to initialize a test repository. And don't worry; it gets deleted after test execution.</p> <pre><code>package git_test\nimport (\n\"testing\"\ngit \"github.com/purpleclay/gitz\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepository(t *testing.T) {\ngittest.InitRepository(t)\nclient, _ := git.NewClient()\nrepo, _ := client.Repository()\nassert.Equal(t, \"main\", repo.DefaultBranch)\n}\n</code></pre> <p>Where <code>gittest</code> shines is in its ability to customize a repository during initialization through a set of options.</p>"},{"location":"testing/git-test/#with-a-commit-log","title":"With a commit log","text":"<p>Initialize a repository with a predefined log by using the <code>WithLog</code> option. It can contain both commit messages and lightweight tags and is written to the repository in reverse chronological order. The expected format is equivalent to the output from the git command:</p> <p><code>git log --pretty='format:%d %s'</code>.</p> <pre><code>package git_test\nimport (\n\"testing\"\ngit \"github.com/purpleclay/gitz\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepositoryWithLog(t *testing.T) {\nlog := `(tag: 0.1.0) feat: this is a brand new feature\ndocs: write amazing material mkdocs documentation\nci: include github release workflow`\ngittest.InitRepository(t, gittest.WithLog(log))\nclient, _ := git.NewClient()\nrepoLog, _ := client.Log()\nassert.Equal(t, \"feat: this is a brand new feature\",\nrepoLog.Commits[0].Message)\nassert.Equal(t, \"docs: write amazing material mkdocs documentation\",\nrepoLog.Commits[1].Message)\nassert.Equal(t, \"ci: include github release workflow\",\nrepoLog.Commits[2].Message)\n}\n</code></pre>"},{"location":"testing/git-test/#multi-line-commits","title":"Multi-line commits","text":"<p>Import multi-line commits by prefixing each commit with a <code>&gt;</code> token. The expected format is equivalent to the output from the git command:</p> <p><code>git log --pretty='format:&gt; %d %s%+b%-N'</code></p> <pre><code>&gt; (tag: 0.1.0, main, origin/main) feat: multi-line commits is supported\n&gt; feat(deps): bump github.com/stretchr/testify from 1.8.1 to 1.8.2\n\nSigned-off-by: dependabot[bot] &lt;support@github.com&gt;\nCo-authored-by: dependabot[bot] &lt;49699333+dependabot[bot]@users.noreply.github.com&gt;\n</code></pre>"},{"location":"testing/git-test/#with-a-remote-log","title":"With a remote log","text":"<p>Initialize the remote origin of a repository with a predefined log using the <code>WithRemoteLog</code> option. Ideal for simulating a delta between the current log and its remote counterpart.</p> <pre><code>package git_test\nimport (\n\"testing\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepositoryRemoteLog(t *testing.T) {\nlog := \"(main, origin/main) chore: testing remote log\"\ngittest.InitRepository(t, gittest.WithRemoteLog(log))\nrequire.NotEqual(t, gittest.LastCommit(t).Message,\n\"chore: testing remote log\")\nclient, _ := git.NewClient()\n_, err := client.Pull()\nrequire.NoError(t, err)\nassert.Equal(t, gittest.LastCommit(t).Message,\n\"chore: testing remote log\")\n}\n</code></pre>"},{"location":"testing/git-test/#with-untracked-files","title":"With untracked files","text":"<p>Create a set of untracked files within a repository using the <code>WithFiles</code> option. File paths can be fully qualified or relative to the repository root. Each created file will contain a sample of <code>lorem ipsum</code> text.</p> <pre><code>package git_test\nimport (\n\"testing\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepositoryWithFiles(t *testing.T) {\ngittest.InitRepository(t, gittest.WithFiles(\"a.txt\", \"dir/b.txt\"))\nstatus := gittest.PorcelainStatus(t)\nassert.Equal(t, \"?? a.txt\", status[0])\nassert.Equal(t, \"?? dir/\", status[1])\n}\n</code></pre>"},{"location":"testing/git-test/#with-staged-files","title":"With staged files","text":"<p>Create a set of staged (or tracked) files within a repository using the <code>WithStagedFiles</code> option.</p> <pre><code>package git_test\nimport (\n\"testing\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepositoryWithStagedFiles(t *testing.T) {\ngittest.InitRepository(t,\ngittest.WithStagedFiles(\"a.txt\", \"dir/b.txt\"))\nstatus := gittest.PorcelainStatus(t)\nassert.Equal(t, \"A  a.txt\", status[0])\nassert.Equal(t, \"A  dir/b.txt\", status[1])\n}\n</code></pre>"},{"location":"testing/git-test/#with-local-commits","title":"With local commits","text":"<p>Generate a set of local empty commits, ready to be pushed back to the remote, with the <code>WithLocalCommits</code> option. Generated Commits will be in chronological order.</p> <pre><code>package git_test\nimport (\n\"testing\"\ngit \"github.com/purpleclay/gitz\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepositoryWithLocalCommits(t *testing.T) {\ncommits := []string{\n\"docs: my first local commit\",\n\"fix: my second local commit\",\n\"feat: my third local commit\",\n}\ngittest.InitRepository(t, gittest.WithLocalCommits(commits...))\nclient, _ := git.NewClient()\nlog, _ := client.Log()\nassert.Equal(t, \"feat: my third local commit\", log.Commits[0].Message)\nassert.Equal(t, \"fix: my second local commit\", log.Commits[1].Message)\nassert.Equal(t, \"docs: my first local commit\", log.Commits[2].Message)\n}\n</code></pre>"},{"location":"testing/git-test/#with-clone-depth","title":"With clone depth","text":"<p>Shallow clone a repository by truncating its history to a set depth.</p> <pre><code>package git_test\nimport (\n\"testing\"\ngit \"github.com/purpleclay/gitz\"\n\"github.com/purpleclay/gitz/gittest\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc TestInitRepositoruWithCloneDepth(t *testing.T) {\nlog := `(tag: 0.1.0) feat: this is a brand new feature\ndocs: write amazing material mkdocs documentation\nci: include github release workflow`\ngittest.InitRepository(t,\ngittest.WithLog(log), gittest.WithCloneDepth(1))\nclient, _ := git.NewClient()\nrepoLog, _ := client.Log()\nrequire.Len(t, repoLog, 1)\nassert.Equal(t, \"feat: this is a brand new feature\",\nrepoLog.Commits[0].Message)\n}\n</code></pre>"},{"location":"testing/git-test/#option-initialization-order","title":"Option initialization order","text":"<p>You can use any combination of options during repository initialization, but a strict order is applied.</p> <ol> <li><code>WithLog</code>: log history imported, both local and remote are in sync.</li> <li><code>WithCloneDepth</code>: shallow clone at the required depth.</li> <li><code>WithRemoteLog</code>: remote log history imported, creating a delta between local and remote.</li> <li><code>WithLocalCommits</code>: local commits created and not pushed back to remote.</li> <li><code>WithFiles</code> and <code>WithStagedFiles</code>: files generated and staged if needed.</li> </ol>"}]}