{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Gitz","text":"<p>Write fluent interactions to Git using the <code>gitz</code> library. Programmatically crafting git commands becomes a breeze! Verify your code using the inbuilt testing framework.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2023 Purple Clay</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"git/checks/","title":"Git checks and how to use them","text":"<p><code>gitz</code> comes with a series of inbuilt checks for inspecting the environment and current repository.</p>"},{"location":"git/checks/#checking-for-the-existence-of-a-git-client","title":"Checking for the existence of a Git Client","text":"<p>When creating a new client, <code>gitz</code> will check for the existence of git using the <code>PATH</code> environment variable. An error is returned if no client exists.</p> <pre><code>package main\nfunc main() {\nclient, err := git.NewClient()\nif err != nil {\nlog.Fatal(err.Error())\n}\nfmt.Println(client.Version())\n}\n</code></pre>"},{"location":"git/checks/#checking-the-integrity-of-a-repository","title":"Checking the Integrity of a Repository","text":"<p>Check the integrity of a repository by running a series of tests and capturing the results for inspection.</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\nrepo, err := client.Repository()\nif err != nil {\nlog.Fatal(\"failed to check the current repository\")\n}\nfmt.Printf(\"Default Branch: %s\\n\", repo.DefaultBranch)\nfmt.Printf(\"Shallow Clone:  %t\\n\", repo.ShallowClone)\nfmt.Printf(\"Detached Head:  %t\\n\", repo.DetachedHead)\n}\n</code></pre> <p>Example output when checking the integrity of a repository cloned within a CI system:</p> <pre><code>Default Branch: main\nShallow Clone:  false\nDetached Head:  true\n</code></pre>"},{"location":"git/commit/","title":"Committing changes to a Repository","text":"<p> Git Documentation</p> <p>Create a commit (snapshot of changes) within the current repository and describe those changes with a given log message. A commit will only exist within the local history until pushed back to the repository remote.</p>"},{"location":"git/commit/#commit-a-snapshot-of-repository-changes","title":"Commit a Snapshot of Repository Changes","text":"<p>Calling <code>Commit</code> with a message will create a new commit within the repository:</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\n// stage all changes to files and folders\n_, err := client.Commit(\"feat: a brand new feature\")\nif err != nil {\nlog.Fatal(\"failed to commit latest changes within repository\")\n}\n}\n</code></pre> <p>And to verify its creation:</p> <pre><code>$ git log -n1\n\ncommit 703a6c9bc9ee91d0c226b169b131670fb92d9a0a (HEAD -&gt; main)\nAuthor: Purple Clay &lt;**********(at)*******&gt;\nDate:   Mon Feb 20 20:43:49 2023 +0000\n\nfeat: a brand new feature\n</code></pre>"},{"location":"git/log/","title":"Inspecting the Commit Log of a Repository","text":"<p> Git Documentation</p> <p>Retrieve the commit log of a repository in an easy-to-parse format.</p>"},{"location":"git/log/#view-the-entire-log","title":"View the entire log","text":"<p>Calling <code>Log</code> without any options will retrieve the entire repository log from the current branch. A default formatting of <code>--pretty=oneline --no-decorate --no-color</code> is applied by <code>gitz</code> during log retrieval:</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\nlog, err := client.Log()\nif err != nil {\nlog.Fatal(\"failed to retrieve repository log\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre> <p>Printing the <code>Raw</code> output from this command:</p> <pre><code>99cb396148cff7db435cebb9a8ea95a11b5658e1 fix: parsing error when input string is too long\ne8b67f90c613340fd61392fda03181d86a7febbe ci: extend the existing build workflow to include integration tests\nc90e819baa6ddc212811924c51256e65f53d4c32 docs: create initial mkdocs material documentation\n1635f10b81a810833b163793e6ef902d52a89789 feat: add first feature to library\na09348464773e99dbc94a5494b5b83b253c18019 initialized repository\n</code></pre> <p>By default, <code>gitz</code> parses the log into a structured output accessible through the <code>Commits</code> property. This structure contains each commit's associated <code>Hash</code>, <code>Abbreviated Hash</code>, and <code>Message</code>.</p>"},{"location":"git/log/#return-only-raw-output-from-the-log","title":"Return only raw output from the log","text":"<p>Use the <code>WithRawOnly</code> option to skip parsing of the log into the structured <code>Commits</code> property, improving performance. Perfect if you want to carry out any custom processing.</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\nlog, err := client.Log(git.WithRawOnly())\nif err != nil {\nlog.Fatal(\"failed to retrieve repository log\")\n}\nfmt.Println(log.Commits)\n}\n</code></pre> <p>Printing the <code>Commits</code> property should now be an empty slice:</p> <pre><code>[]\n</code></pre>"},{"location":"git/log/#view-the-log-from-a-point-in-time","title":"View the log from a point in time","text":"<p>The <code>WithRef</code> option provides a starting point other than HEAD (most recent commit) when retrieving the log history. A reference can be a <code>Commit Hash</code>, <code>Branch Name</code>, or <code>Tag</code>. Output from this option will be a shorter, fine-tuned log.</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\nlog, err := client.Log(git.WithRef(\"0.1.0\"))\nif err != nil {\nlog.Fatal(\"failed to retrieve log for tag 0.1.0\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre>"},{"location":"git/log/#view-a-snapshot-of-the-log","title":"View a snapshot of the log","text":"<p>The <code>WithRefRange</code> option provides a start and end point for retrieving a snapshot of the log history between two points in time. A reference can be a <code>Commit Hash</code>, <code>Branch Name</code>, or <code>Tag</code>. Output from this option will be a shorter, fine-tuned log.</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\nlog, err := client.Log(git.WithRefRange(\"0.2.0\", \"0.1.0\"))\nif err != nil {\nlog.Fatal(\"failed to retrieve log between tags 0.2.0 and 0.1.0\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre>"},{"location":"git/log/#view-the-log-of-any-files-or-folders","title":"View the log of any files or folders","text":"<p>Fine-tune the log history further with the <code>WithPaths</code> option. Providing a set of relative paths to any files and folders within the repository will include only commits related to their history.</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\n// commits are made to the following files in a newly initialized\n// repository:\n//  &gt; a.txt\n//    ~ fix: typos in file content\n//  &gt; b.txt\n//    ~ chore: restructure file into expected format\n//  &gt; dir1 (b.txt, c.txt)\n//    ~ feat: a brand new feature\nlog, err := client.Log(git.WithPaths(\"a.txt\", \"dir1\"))\nif err != nil {\nlog.Fatal(\"failed to retrieve log using custom paths\")\n}\nfmt.Println(log.Raw)\n}\n</code></pre> <p>Printing the <code>Raw</code> output from this command:</p> <pre><code>d611a22c1a009bd74bc2c691b331b9df38828dae fix: typos in file content\n9b342465255d1a8ec4f5517eef6049e5bcc8fb45 feat: a brand new feature\n</code></pre>"},{"location":"git/pull/","title":"Pulling the latest changes from a Remote","text":"<p> Git Documentation</p> <p>Pull all changes from a remote repository into the current branch. Ensures the existing repository keeps track of remote changes and stays in sync.</p>"},{"location":"git/pull/#pull-the-latest-changes-from-the-current-branch","title":"Pull the latest changes from the current Branch","text":"<p>Calling <code>Pull</code> will attempt to sync the current branch with its counterpart from the remote:</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\n// a new file was added to the hierarchy at the remote:\n//  &gt; folder\n//    &gt; c.txt\nout, err := client.Pull()\nif err != nil {\nlog.Fatal(\"failed to pull latest changes from remote\")\n}\nfmt.Println(out)\n}\n</code></pre> <p>Printing the output from this command:</p> <pre><code>remote: Enumerating objects: 5, done.\nremote: Counting objects: 100% (5/5), done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), 300 bytes | 150.00 KiB/s, done.\nFrom /Users/paulthomas/dev/./gitrepo\n   703a6c9..8e87f78  main       -&gt; origin/main\nUpdating 703a6c9..8e87f78\nFast-forward\n folder/c.txt | 1 +\n 1 file changed, 1 insertion(+)\n create mode 100644 folder/c.txt\n</code></pre>"},{"location":"git/push/","title":"Pushing the latest changes to a Remote","text":"<p> Git Documentation</p> <p>Push all local repository changes back to the remote, ensuring all references are tracked and both instances are in sync.</p>"},{"location":"git/push/#push-committed-changes-back-to-the-remote","title":"Push committed changes back to the Remote","text":"<p>Calling <code>Push</code> will attempt to push all locally committed changes back to the remote for the current branch:</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\n// all changes have been staged and committed locally\n_, err := client.Push()\nif err != nil {\nlog.Fatal(\"failed to push committed changes to the remote\")\n}\n}\n</code></pre>"},{"location":"git/push/#push-the-created-tag-back-to-the-remote","title":"Push the created tag back to the Remote","text":"<p>Calling <code>PushTag</code> will attempt to push the newly created tag back to the remote:</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\n// tag 0.1.0 has been created and is tracked locally\n_, err := client.PushTag(\"0.1.0\")\nif err != nil {\nlog.Fatal(\"failed to push tag 0.1.0 to the remote\")\n}\n}\n</code></pre>"},{"location":"git/stage/","title":"Staging changes within a Repository","text":"<p> Git Documentation</p> <p>Stage changes to a particular file or folder within the current repository for inclusion within the next commit. Staging is a prerequisite to committing and pushing changes back to the repository remote.</p>"},{"location":"git/stage/#staging-a-file-or-folder","title":"Staging a File or Folder","text":"<p>Calling <code>Stage</code> with a relative path to an individual file or folder will stage any changes:</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\n// create multiple files within the following hierarchy:\n//  &gt; root.txt\n//  &gt; folder\n//    &gt; a.txt\n//    &gt; b.txt\n_, err := client.Stage(\"root.txt\")\nif err != nil {\nlog.Fatal(\"failed to stage file root.txt\")\n}\n_, err := client.Stage(\"folder/\")\nif err != nil {\nlog.Fatal(\"failed to stage all changes within directory folder/\")\n}\n}\n</code></pre> <p>And to verify the staged changes:</p> <pre><code>$ git status\n\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\nnew file:   folder/a.txt\n    new file:   folder/b.txt\n    new file:   root.txt\n</code></pre>"},{"location":"git/tag/","title":"Tagging a Repositories History","text":"<p> Git Documentation</p> <p>Tag a specific time point within a repository's history and push it to the configured remote. Tagging comes in two flavors, a <code>lightweight</code> and <code>annotated</code> tag. The main difference being an annotated tag is treated as a complete object within git and must include a message (or annotation). When querying the git history, an annotated tag will contain details such as the author and its GPG signature, if signed.</p> <p>Gitz supports both tags but defaults to creating the lightweight variant unless instructed.</p>"},{"location":"git/tag/#creating-a-lightweight-tag","title":"Creating a Lightweight Tag","text":"<p>Calling <code>Tag</code> with a valid name<sup>1</sup> will tag the repository with a lightweight tag:</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Tag(\"0.1.0\")\nif err != nil {\nlog.Fatal(\"failed to tag repository with version 0.1.0\")\n}\n}\n</code></pre> Do you know the git tag naming restrictions? <ol> <li>Tags cannot begin, end with, or contain multiple consecutive <code>/</code> characters.</li> <li>Tags cannot contain any of the following characters: <code>\\ ? ~ ^ : * [ @</code></li> <li>Tags cannot contain a space <code></code>.</li> <li>Tags cannot end with a dot <code>.</code> or contain two consecutive dots <code>..</code> anywhere within them.</li> </ol>"},{"location":"git/tag/#creating-an-annotated-tag","title":"Creating an Annotated Tag","text":"<p>Use the <code>WithAnnotation</code> option to switch to annotated tag creation mode:</p> <pre><code>package main\nfunc main() {\nclient, _ := git.NewClient()\n_, err := client.Tag(\"0.1.0\", git.WithAnnotation(\"created tag 0.1.0\"))\nif err != nil {\nlog.Fatal(\"failed to tag repository with version 0.1.0\")\n}\n}\n</code></pre> <p>If you were to inspect the annotated tag, details about the author are now included:</p> <pre><code>$ git show 0.1.0\n\ntag 0.1.0\nTagger: Purple Clay &lt;**********(at)*******&gt;\nDate:   Mon Feb 20 05:58:55 2023 +0000\n\ncreated tag 0.1.0\n\n... # (1)!\n</code></pre> <ol> <li>The associated commit was replaced with a <code>...</code> for brevity</li> </ol> <ol> <li> <p>Gitz defers the validation of a tag name to the git client. Any error is captured and returned back to the caller\u00a0\u21a9</p> </li> </ol>"},{"location":"install/package/","title":"Installing the Package","text":"<p>Use <code>go get</code> to pull the <code>gitz</code> package as a dependency within your <code>go.mod</code> file:</p> <pre><code>go get github.com/purpleclay/gitz\n</code></pre> <p>Then to get started, import the package into your project:</p> <pre><code>import git \"github.com/purpleclay/gitz\"\n</code></pre> <p>And that's it!</p>"},{"location":"testing/git-test/","title":"Testing your Interactions with Git","text":"<p><code>gitz</code> includes a <code>gittest</code> package that enables interactions with Git to be unit tested within your projects. Add the following import to any of your test files to get started:</p> <pre><code>import \"github.com/purpleclay/gitz/gittest\"\n</code></pre>"},{"location":"testing/git-test/#building-a-test-repository","title":"Building a test repository","text":"<p> Experimental</p> <p>Only a single line of code is needed to initialize a test repository. And don't worry; it gets deleted after test execution.</p> <pre><code>package main_test\nimport (\n\"testing\"\n\"github.com/purpleclay/gitz/gittest\"\n)\nfunc TestGreatFeature(t *testing.T) {\ngittest.InitRepository(t)\n// test logic and assertions to follow ...\n}\n</code></pre> <p>Where <code>gittest</code> shines is in its ability to customize a repository during initialization through a set of options.</p>"},{"location":"testing/git-test/#with-a-commit-log","title":"With a commit log","text":"<p>Initialize a repository with a predefined log by using the <code>WithLog</code> option. It can contain both commit messages and lightweight tags and is written to the repository in reverse chronological order. The expected format is equivalent to the output from the git command: <code>git log --pretty='format:%d %s'</code>.</p> <pre><code>func TestGreatFeature(t *testing.T) {\nlog := `(tag: 0.1.0) feat: this is a brand new feature\ndocs: write amazing material mkdocs documentation\nci: include github release workflow`\ngittest.InitRepository(t, gittest.WithLog(log))\n// test logic and assertions to follow ...\n}\n</code></pre>"},{"location":"testing/git-test/#with-a-remote-log","title":"With a remote log","text":"<p>Initialize the remote origin of a repository with a predefined log using the <code>WithRemoteLog</code> option. Ideal for simulating a delta between the current log and its remote counterpart.</p> <pre><code>func TestGreatFeature(t *testing.T) {\nlog := `(tag: 0.1.0) feat: this is a brand new feature\ndocs: write amazing material mkdocs documentation\nci: include github release workflow`\ngittest.InitRepository(t, gittest.WithRemoteLog(log))\n// test logic and assertions to follow ...\n}\n</code></pre>"},{"location":"testing/git-test/#with-untracked-files","title":"With untracked files","text":"<p>Create a set of untracked files within a repository using the <code>WithFiles</code> option. File paths can be fully qualified or relative to the repository root. Each created file will contain a sample of <code>lorem ipsum</code> text.</p> <pre><code>func TestGreatFeature(t *testing.T) {\ngittest.InitRepository(t, gittest.WithFiles(\"a.txt\", \"dir/b.txt\"))\n// test logic and assertions to follow ...\n}\n</code></pre> <p>Querying the repository status:</p> <pre><code>$ git status --porcelain\n?? a.txt\n?? dir/b.txt\n</code></pre>"},{"location":"testing/git-test/#with-staged-files","title":"With staged files","text":"<p>Create a set of staged (or tracked) files within a repository using the <code>WithStagedFiles</code> option.</p> <pre><code>func TestGreatFeature(t *testing.T) {\ngittest.InitRepository(t, gittest.WithStagedFiles(\"a.txt\", \"dir/b.txt\"))\n// test logic and assertions to follow ...\n}\n</code></pre> <p>Querying the repository status:</p> <pre><code>$ git status --porcelain\nA  a.txt\nA  dir/b.txt\n</code></pre>"},{"location":"testing/git-test/#with-local-commits","title":"With local commits","text":"<p>Generate a set of local empty commits, ready to be pushed back to the remote, with the <code>WithLocalCommits</code> option. Generated Commits will be in chronological order.</p> <pre><code>func TestGreatFeature(t *testing.T) {\ncommits := []string{\n\"docs: my first local commit\",\n\"fix: my second local commit\",\n\"feat: my third local commit\",\n}\ngittest.InitRepository(t, gittest.WithLocalCommits(commits...))\n// test logic and assertions to follow ...\n}\n</code></pre>"},{"location":"testing/git-test/#option-initialization-order","title":"Option initialization order","text":"<p>You can use any combination of options during repository initialization, but a strict order is applied.</p> <ol> <li><code>WithLog</code>: log history imported, both local and remote are in sync.</li> <li><code>WithRemoteLog</code>: remote log history imported, creating a delta between local and remote.</li> <li><code>WithLocalCommits</code>: local commits created and not pushed back to remote.</li> <li><code>WithFiles</code> and <code>WithStagedFiles</code>: files generated and staged if needed.</li> </ol>"}]}